{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useTaskContext } from '../context/TaskContext';\nimport { getTaskStatus, initiateTaskProcessing } from '../api/taskApi';\nconst POLLING_INTERVAL = 2000; // 2 seconds\nconst MAX_RETRIES = 3;\nconst useTaskPolling = () => {\n  _s();\n  const {\n    updateTask\n  } = useTaskContext();\n  const pollingTasks = useRef({});\n  const startPolling = useCallback(taskId => {\n    // If already polling this task, clear the interval first\n    if (pollingTasks.current[taskId]) {\n      stopPolling(taskId);\n    }\n\n    // Start the simulated task processing\n    initiateTaskProcessing(taskId);\n\n    // Start polling for status updates\n    const intervalId = window.setInterval(async () => {\n      try {\n        const taskStatus = await getTaskStatus(taskId);\n\n        // Update task in context with new status\n        updateTask(taskId, {\n          status: taskStatus.status,\n          progress: taskStatus.progress,\n          message: taskStatus.message || taskStatus.error,\n          ...(taskStatus.status === 'success' || taskStatus.status === 'error' || taskStatus.status === 'cancelled' ? {\n            completedAt: new Date()\n          } : {})\n        });\n\n        // Reset retries on successful poll\n        if (pollingTasks.current[taskId]) {\n          pollingTasks.current[taskId].retries = 0;\n        }\n\n        // If task is complete or failed, stop polling\n        if (taskStatus.status === 'success' || taskStatus.status === 'error' || taskStatus.status === 'cancelled') {\n          stopPolling(taskId);\n        }\n      } catch (error) {\n        // Track retry attempts\n        const taskInfo = pollingTasks.current[taskId];\n        if (taskInfo) {\n          taskInfo.retries += 1;\n\n          // If max retries reached, stop polling and mark as error\n          if (taskInfo.retries >= MAX_RETRIES) {\n            updateTask(taskId, {\n              status: 'error',\n              message: 'Failed to check status after multiple attempts',\n              completedAt: new Date()\n            });\n            stopPolling(taskId);\n          }\n        }\n      }\n    }, POLLING_INTERVAL);\n\n    // Store interval ID for cleanup\n    pollingTasks.current[taskId] = {\n      intervalId,\n      retries: 0\n    };\n  }, [updateTask]);\n  const stopPolling = useCallback(taskId => {\n    if (pollingTasks.current[taskId]) {\n      clearInterval(pollingTasks.current[taskId].intervalId);\n      delete pollingTasks.current[taskId];\n    }\n  }, []);\n\n  // Clean up all polling intervals on unmount\n  useEffect(() => {\n    return () => {\n      Object.entries(pollingTasks.current).forEach(([taskId, {\n        intervalId\n      }]) => {\n        clearInterval(intervalId);\n      });\n    };\n  }, []);\n  return {\n    startPolling,\n    stopPolling\n  };\n};\n_s(useTaskPolling, \"XDU/R5gmG2cf0GRWRZwAXR/BRnA=\", false, function () {\n  return [useTaskContext];\n});\nexport default useTaskPolling;","map":{"version":3,"names":["useCallback","useEffect","useRef","useTaskContext","getTaskStatus","initiateTaskProcessing","POLLING_INTERVAL","MAX_RETRIES","useTaskPolling","_s","updateTask","pollingTasks","startPolling","taskId","current","stopPolling","intervalId","window","setInterval","taskStatus","status","progress","message","error","completedAt","Date","retries","taskInfo","clearInterval","Object","entries","forEach"],"sources":["/Users/gurusajinithillainathan/Documents/Source/Bundle/file-app/File_Upload_Simulator/src/hooks/useTaskPolling.tsx"],"sourcesContent":["import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useTaskContext } from '../context/TaskContext';\nimport { getTaskStatus, initiateTaskProcessing } from '../api/taskApi';\n\nconst POLLING_INTERVAL = 2000; // 2 seconds\nconst MAX_RETRIES = 3;\n\nconst useTaskPolling = () => {\n  const { updateTask } = useTaskContext();\n  type PollingTask = {\n    intervalId: number;\n    retries: number;\n  };\n  \n  const pollingTasks = useRef<Record<string, PollingTask>>({});\n  \n  const startPolling = useCallback((taskId: string) => {\n    // If already polling this task, clear the interval first\n    if (pollingTasks.current[taskId]) {\n      stopPolling(taskId);\n    }\n    \n    // Start the simulated task processing\n    initiateTaskProcessing(taskId);\n    \n    // Start polling for status updates\n    const intervalId = window.setInterval(async () => {\n      try {\n        const taskStatus = await getTaskStatus(taskId);\n        \n        // Update task in context with new status\n        updateTask(taskId, {\n          status: taskStatus.status,\n          progress: taskStatus.progress,\n          message: taskStatus.message || taskStatus.error,\n          ...(taskStatus.status === 'success' || \n             taskStatus.status === 'error' || \n             taskStatus.status === 'cancelled' \n             ? { completedAt: new Date() } : {}),\n        });\n        \n        // Reset retries on successful poll\n        if (pollingTasks.current[taskId]) {\n          pollingTasks.current[taskId].retries = 0;\n        }\n        \n        // If task is complete or failed, stop polling\n        if (taskStatus.status === 'success' || \n            taskStatus.status === 'error' || \n            taskStatus.status === 'cancelled') {\n          stopPolling(taskId);\n        }\n      } catch (error) {\n        // Track retry attempts\n        const taskInfo = pollingTasks.current[taskId];\n        if (taskInfo) {\n          taskInfo.retries += 1;\n          \n          // If max retries reached, stop polling and mark as error\n          if (taskInfo.retries >= MAX_RETRIES) {\n            updateTask(taskId, {\n              status: 'error',\n              message: 'Failed to check status after multiple attempts',\n              completedAt: new Date(),\n            });\n            stopPolling(taskId);\n          }\n        }\n      }\n    }, POLLING_INTERVAL);\n    \n    // Store interval ID for cleanup\n    pollingTasks.current[taskId] = {\n      intervalId,\n      retries: 0,\n    };\n  }, [updateTask]);\n  \n  const stopPolling = useCallback((taskId: string) => {\n    if (pollingTasks.current[taskId]) {\n      clearInterval(pollingTasks.current[taskId].intervalId);\n      delete pollingTasks.current[taskId];\n    }\n  }, []);\n  \n  // Clean up all polling intervals on unmount\n  useEffect(() => {\n    return () => {\n      Object.entries(pollingTasks.current).forEach(([taskId, { intervalId }]) => {\n        clearInterval(intervalId);\n      });\n    };\n  }, []);\n\n  return { startPolling, stopPolling };\n};\n\nexport default useTaskPolling;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}