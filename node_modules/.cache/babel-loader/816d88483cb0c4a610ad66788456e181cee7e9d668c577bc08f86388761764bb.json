{"ast":null,"code":"// Mock response delay to simulate network latency\nconst randomDelay = (min, max) => {\n  const delay = Math.floor(Math.random() * (max - min + 1)) + min;\n  return new Promise(resolve => setTimeout(resolve, delay));\n};\n\n// Simulate task processing\nconst mockTaskProcessing = async (taskId, onStatusUpdate) => {\n  // Set initial status to processing\n  onStatusUpdate({\n    status: 'processing',\n    progress: 0\n  });\n  try {\n    // Simulate 5-10 second processing time with progress updates\n    const totalSteps = 10;\n    const processTime = 5000 + Math.random() * 5000; // 5-10 seconds\n    const stepTime = processTime / totalSteps;\n    for (let step = 1; step <= totalSteps; step++) {\n      await randomDelay(stepTime * 0.8, stepTime * 1.2);\n\n      // Check for cancellation flag (stored in localStorage for this mock)\n      if (localStorage.getItem(`cancel_${taskId}`) === 'true') {\n        onStatusUpdate({\n          status: 'cancelled',\n          message: 'Task was cancelled'\n        });\n        return;\n      }\n\n      // Random chance of error (10%)\n      if (Math.random() < 0.1 && step > 3) {\n        throw new Error('Simulated processing error');\n      }\n\n      // Update progress\n      const progress = Math.round(step / totalSteps * 100);\n      onStatusUpdate({\n        status: 'processing',\n        progress,\n        message: `Processing file (${progress}%)`\n      });\n    }\n\n    // Complete successfully\n    onStatusUpdate({\n      status: 'success',\n      progress: 100,\n      message: 'File processed successfully'\n    });\n  } catch (error) {\n    // Handle error\n    onStatusUpdate({\n      status: 'error',\n      message: error instanceof Error ? error.message : 'Unknown error occurred'\n    });\n  }\n};\n\n// Mock upload API\nexport const uploadFile = async file => {\n  // Simulate network delay\n  await randomDelay(500, 1500);\n\n  // 15% chance of upload error\n  if (Math.random() < 0.15) {\n    throw new Error('Network error during upload');\n  }\n\n  // Return mock task ID\n  const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  return {\n    task_id: taskId\n  };\n};\n\n// Mock status API\nexport const getTaskStatus = async taskId => {\n  // Simulate network delay\n  await randomDelay(200, 800);\n\n  // 10% chance of network error\n  if (Math.random() < 0.1) {\n    throw new Error('Network error while checking status');\n  }\n\n  // Get status from local store or return pending\n  const status = localStorage.getItem(`status_${taskId}`);\n  if (status) {\n    return JSON.parse(status);\n  }\n  return {\n    status: 'pending'\n  };\n};\n\n// Initiate task processing\nexport const initiateTaskProcessing = taskId => {\n  // Clear any existing cancellation\n  localStorage.removeItem(`cancel_${taskId}`);\n\n  // Start the mock processing\n  mockTaskProcessing(taskId, status => {\n    localStorage.setItem(`status_${taskId}`, JSON.stringify(status));\n  });\n};\n\n// Cancel a task\nexport const cancelTask = taskId => {\n  localStorage.setItem(`cancel_${taskId}`, 'true');\n};","map":{"version":3,"names":["randomDelay","min","max","delay","Math","floor","random","Promise","resolve","setTimeout","mockTaskProcessing","taskId","onStatusUpdate","status","progress","totalSteps","processTime","stepTime","step","localStorage","getItem","message","Error","round","error","uploadFile","file","Date","now","toString","substr","task_id","getTaskStatus","JSON","parse","initiateTaskProcessing","removeItem","setItem","stringify","cancelTask"],"sources":["/Users/gurusajinithillainathan/Documents/Source/Bundle/file-app/File_Upload_Simulator/src/api/taskApi.ts"],"sourcesContent":["import { TaskResponse, TaskStatusResponse } from '../types';\n\n// Mock response delay to simulate network latency\nconst randomDelay = (min: number, max: number) => {\n  const delay = Math.floor(Math.random() * (max - min + 1)) + min;\n  return new Promise(resolve => setTimeout(resolve, delay));\n};\n\n// Simulate task processing\nconst mockTaskProcessing = async (\n  taskId: string, \n  onStatusUpdate: (status: TaskStatusResponse) => void\n) => {\n  // Set initial status to processing\n  onStatusUpdate({ status: 'processing', progress: 0 });\n  \n  try {\n    // Simulate 5-10 second processing time with progress updates\n    const totalSteps = 10;\n    const processTime = 5000 + Math.random() * 5000; // 5-10 seconds\n    const stepTime = processTime / totalSteps;\n    \n    for (let step = 1; step <= totalSteps; step++) {\n      await randomDelay(stepTime * 0.8, stepTime * 1.2);\n      \n      // Check for cancellation flag (stored in localStorage for this mock)\n      if (localStorage.getItem(`cancel_${taskId}`) === 'true') {\n        onStatusUpdate({\n          status: 'cancelled',\n          message: 'Task was cancelled',\n        });\n        return;\n      }\n      \n      // Random chance of error (10%)\n      if (Math.random() < 0.1 && step > 3) {\n        throw new Error('Simulated processing error');\n      }\n      \n      // Update progress\n      const progress = Math.round((step / totalSteps) * 100);\n      onStatusUpdate({\n        status: 'processing',\n        progress,\n        message: `Processing file (${progress}%)`,\n      });\n    }\n    \n    // Complete successfully\n    onStatusUpdate({\n      status: 'success',\n      progress: 100,\n      message: 'File processed successfully',\n    });\n  } catch (error) {\n    // Handle error\n    onStatusUpdate({\n      status: 'error',\n      message: error instanceof Error ? error.message : 'Unknown error occurred',\n    });\n  }\n};\n\n// Mock upload API\nexport const uploadFile = async (file: File): Promise<TaskResponse> => {\n  // Simulate network delay\n  await randomDelay(500, 1500);\n  \n  // 15% chance of upload error\n  if (Math.random() < 0.15) {\n    throw new Error('Network error during upload');\n  }\n  \n  // Return mock task ID\n  const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  return { task_id: taskId };\n};\n\n// Mock status API\nexport const getTaskStatus = async (taskId: string): Promise<TaskStatusResponse> => {\n  // Simulate network delay\n  await randomDelay(200, 800);\n  \n  // 10% chance of network error\n  if (Math.random() < 0.1) {\n    throw new Error('Network error while checking status');\n  }\n  \n  // Get status from local store or return pending\n  const status = localStorage.getItem(`status_${taskId}`);\n  if (status) {\n    return JSON.parse(status);\n  }\n  \n  return { status: 'pending' };\n};\n\n// Initiate task processing\nexport const initiateTaskProcessing = (taskId: string) => {\n  // Clear any existing cancellation\n  localStorage.removeItem(`cancel_${taskId}`);\n  \n  // Start the mock processing\n  mockTaskProcessing(taskId, (status) => {\n    localStorage.setItem(`status_${taskId}`, JSON.stringify(status));\n  });\n};\n\n// Cancel a task\nexport const cancelTask = (taskId: string) => {\n  localStorage.setItem(`cancel_${taskId}`, 'true');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}